@precedence {
  typeargs,
  typeMember,
  typePrefix,
  intersection @left,
  union @left,
  typeTernary @right,
  else @right,
  member,
  newArgs,
  call,
  prefix,
  postfix,
  typeof,
  exp @left,
  times @left,
  plus @left,
  shift @left,
  loop,
  rel @left,
  equal @left,
  and @left,
  or @left,
  ternary @right,
  assign @right,
  comma @left,
  statement @cut,
  predicate
}

@top Script { statement+ }

statement[@isGroup=Statement] {
  ForStatement { kw<"for"> ckw<"await">? (ForSpec | ForInSpec | ForOfSpec) statement } |
  IfStatement { kw<"if"> ParenthesizedExpression statement (!else kw<"else"> statement)? } |
  SwitchStatement { kw<"switch"> ParenthesizedExpression SwitchBody { "{" switchItem* "}" } } |
  TryStatement { kw<"try"> Block (kw<"catch"> ("(" pattern ")")? Block)? (kw<"finally"> Block)? } |
  ReturnStatement { kw<"return"> (noSemi expression)? semi } |
  ThrowStatement { kw<"throw"> expression semi } |
  BreakStatement { kw<"break"> (noSemi Label)? semi } |
  ContinueStatement { kw<"continue"> (noSemi Label)? semi } |
  DebuggerStatement { kw<"debugger"> semi } |
  Block |
  LabeledStatement { Label ":" statement } |
  declaration |
  ExpressionStatement { expression semi } |
  ";"
}

ForSpec {
  "("
  (VariableDeclaration | expression ";" | ";") expression? ";" expression?
  ")"
}

forXSpec<op> {
  "("
  ((kw<"let"> | kw<"var"> | kw<"const">) pattern | VariableName | MemberExpression | ArrayPattern | ObjectPattern)
  !loop op expression
  ")"
}

ForInSpec { forXSpec<kw<"in">> }
ForOfSpec { forXSpec<ckw<"of">> }

declaration {
  FunctionDeclaration |
  ClassDeclaration |
  VariableDeclaration |
  EnumDeclaration
}

FunctionDeclaration {
  async? !statement kw<"function"> Star? VariableDefinition? functionSignature Block
}

ClassDeclaration {
  !statement (kw<"flow"> | kw<"servicetask"> | kw<"decisiontable">) VariableDefinition
  ClassBody
}

ClassBody {
  "{" (MethodDeclaration | PropertyDeclaration | ";")* "}"
}

MethodDeclaration[group=ClassItem] {
  pkwMod<"async">?
  Star?
  PropertyNameDefinition
  functionSignature
  Block
}

PropertyDeclaration[group=ClassItem] {
  PropertyNameDefinition
  (Optional | LogicOp<"!">)?
  TypeAnnotation?
  ("=" expressionNoComma)?
  semi
}

VariableDeclaration {
  (kw<"let"> | kw<"var"> | kw<"const">) commaSep1<patternAssignTyped> semi
}

EnumDeclaration {
  kw<"const">? tskw<"enum"> TypeDefinition EnumBody { "{" commaSep<PropertyName ("=" expressionNoComma)?> "}" }
}

pattern { VariableDefinition | ArrayPattern | ObjectPattern }

ArrayPattern { "[" commaSep<"..."? patternAssign> ~destructure "]" }

ObjectPattern { "{" commaSep<PatternProperty> ~destructure "}" }

patternAssign {
  pattern ("=" expressionNoComma)?
}

TypeAnnotation { ":" type }

TypePredicate { ":" (VariableName | kw<"this">) !predicate tskw<"is"> type }

patternAssignTyped {
  pattern Optional? TypeAnnotation? ("=" expressionNoComma)?
}

ParamList {
  "(" commaSep<"..."? patternAssignTyped> ")"
}

Block {
  !statement "{" statement* "}"
}

switchItem {
  CaseLabel { kw<"case"> expression ":" } |
  DefaultLabel { kw<"default"> ":" } |
  statement
}

expression[@isGroup=Expression] {
  expressionNoComma | SequenceExpression
}

SequenceExpression {
  expressionNoComma !comma ("," expressionNoComma)+
}

expressionNoComma {
  Number |
  String |
  VariableName |
  boolean |
  kw<"this"> |
  kw<"null"> |
  kw<"super"> |
  RegExp |
  ArrayExpression |
  ObjectExpression { "{" commaSep<Property> ~destructure "}" } |
  NewExpression { kw<"new"> expressionNoComma (!newArgs TypeArgList? ArgList)? } |
  UnaryExpression |
  ParenthesizedExpression |
  ClassExpression |
  FunctionExpression |
  ArrowFunction |
  MemberExpression |
  BinaryExpression |
  ConditionalExpression { expressionNoComma !ternary questionOp expressionNoComma LogicOp<":"> expressionNoComma } |
  AssignmentExpression |
  PostfixExpression { expressionNoComma !postfix (incdec | LogicOp<"!">) } |
  CallExpression { expressionNoComma !call TypeArgList? ArgList }
}

ParenthesizedExpression { "(" expression ")" }

ArrayExpression {
  "[" commaSep1<"..."? expressionNoComma | ""> ~destructure "]"
}

propName { PropertyNameDefinition | "[" expression "]" | Number | String }

Property {
  pkwMod<"async">? (pkwMod<"get"> | pkwMod<"set"> | Star)? propName functionSignature Block |
  propName ~destructure (":" expressionNoComma)? |
  "..." expressionNoComma
}

PatternProperty {
  "..." patternAssign |
  (PropertyName | Number | String) ~destructure (":" pattern)? ("=" expressionNoComma)?
}

ClassExpression {
  kw<"class"> VariableDefinition? (kw<"extends"> expression | TSExtends type)? ClassBody
}

functionSignature { ParamList (TypeAnnotation | TypePredicate)? }

FunctionExpression {
  async? kw<"function"> Star? VariableDefinition? functionSignature Block
}

UnaryExpression {
  !prefix (ckw<"await"> | LogicOp<"!"> | incdec | incdecPrefix | ArithOp<"+" | "-">)
  expressionNoComma
}

BinaryExpression {
  expressionNoComma !exp ArithOp<"**"> expressionNoComma |
  expressionNoComma !times (divide | ArithOp<"%"> | ArithOp<"*">) expressionNoComma |
  expressionNoComma !plus ArithOp<"+" | "-"> expressionNoComma |
  expressionNoComma !rel (LessThan | CompareOp<"<=" | ">" "="?> | kw<"in"> | kw<"instanceof">) expressionNoComma |
  expressionNoComma !equal CompareOp<"==" "="? | "!=" "="?> expressionNoComma |
  expressionNoComma !and LogicOp<"&&"> expressionNoComma |
  expressionNoComma !or LogicOp<"||" | "??"> expressionNoComma
}

AssignmentExpression {
  (VariableName | MemberExpression) !assign UpdateOp<($[+\-/%^] | "*" "*"? | "|" "|"? | "&" "&"? | "<<" | ">>" ">"? | "??") "=">
    expressionNoComma |
  (VariableName | MemberExpression | ArrayPattern | ObjectPattern) !assign "=" expressionNoComma
}

MemberExpression {
  expressionNoComma !member (("." | "?.") PropertyName | "[" expression "]")
}

ArgList {
  "(" commaSep<"..."? expressionNoComma> ")"
}

ArrowFunction {
  async? (ParamList { VariableDefinition } | ParamList TypeAnnotation?) "=>" (Block | expression)
}

TypeArgList {
  @extend[@name="<"]<LessThan, "<"> commaSep<type> ">"
}

typeofMemberExpression[@name=MemberExpression] {
  VariableName !member (("." | "?.") PropertyName | "[" expression "]")
}

type[@isGroup=Type] {
  ThisType { kw<"this"> } |
  LiteralType {
   ArithOp<"+" | "-">? Number |
   boolean |
   String
  } |
  VoidType { kw<"void"> } |
  TypeofType { kw<"typeof"> (VariableName | typeofMemberExpression) } |
  KeyofType { !typePrefix tskw<"keyof"> type } |
  UniqueType { !typePrefix tskw<"unique"> type } |
  InferredType { tskw<"infer"> TypeName } |
  ParenthesizedType { "(" type ")" } |
  FunctionSignature { ParamTypeList "=>" type } |
  NewSignature { kw<"new"> ParamTypeList "=>" type } |
  IndexedType { type !typeMember ("." PropertyName | "[" (String | Number) "]")+ } |
  TupleType { "[" commaSep<(Label ":")? type | "..." type> "]" } |
  ArrayType { type "[" "]" | type "[" "]" } |
  ObjectType |
  UnionType { type !union LogicOp { "|" } type } |
  IntersectionType { type !intersection LogicOp { "&" } type } |
  ConditionalType { type !typeTernary questionOp ~arrow type LogicOp<":"> type } |
  ParameterizedType { TypeName !typeargs TypeArgList } |
  TypeName
}

ObjectType {
  "{" (
    MethodType |
    PropertyType |
    IndexSignature |
    CallSignature { ParamTypeList (TypeAnnotation | TypePredicate) semi } |
    NewSignature[@dynamicPrecedence=1] { @extend[@name=new]<word, "new"> ParamTypeList TypeAnnotation semi } |
    ";"
  )* "}"
}

IndexSignature {
  pkwMod<"readonly">? "[" PropertyNameDefinition (TypeAnnotation | kw<"in"> type) "]" TypeAnnotation semi
}

MethodType {
  pkwMod<"async">?
  (pkwMod<"get"> | pkwMod<"set"> | Star)?
  PropertyNameDefinition
  functionSignature
  semi
}

PropertyType {
  (ArithOp<"+" | "-">? pkwMod<"readonly">)?
  PropertyNameDefinition
  (ArithOp<"+" | "-">? Optional)?
  TypeAnnotation
  semi
}  

ParamTypeList[@name=ParamList] {
  "(" commaSep<"..."? VariableDefinition ~arrow Optional? ~arrow TypeAnnotation?> ")"
}

commaSep<content> {
  "" | content ("," content?)*
}

commaSep1<content> {
  content ("," content)*
}

// Keywords

kw<term> { @specialize[@name={term}]<identifier, term> }

// Contextual keywords

ckw<term> { @extend[@name={term}]<identifier, term> }

tskw<term> { @extend[@name={term}]<identifier, term> }

async { @extend[@name=async]<identifier, "async"> }

// Contextual keyword in property context

pkwMod<term> { @extend[@name={term}]<word, term> }

semi { ";" | insertSemi }

boolean { @specialize[@name=BooleanLiteral]<identifier, "true" | "false"> }

Star { "*" }

VariableName { identifier ~arrow }

VariableDefinition { identifier ~arrow }

TypeDefinition { identifier }

TypeName { identifier ~arrow }

Label { identifier }

PropertyName { word }

PropertyNameDefinition { word }

Optional { "?" }

questionOp[@name=LogicOp] { "?" }

@skip { whitespace | LineComment | BlockComment }

@external extend { identifier } tsExtends from "./tokens" { TSExtends[@name=extends] }

@external tokens noSemicolon from "./tokens" { noSemi }

@external tokens incdecToken from "./tokens" {
 incdec[@name=ArithOp],
 incdecPrefix[@name=ArithOp]
}


@tokens {
  whitespace { std.whitespace+ }

  LineComment { "//" ![\n]* }

  BlockComment { "/*" blockCommentRest }

  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  divide[@name=ArithOp] { "/" }

  @precedence { BlockComment, LineComment, divide }

  @precedence { BlockComment, LineComment, RegExp }

  identifierChar { std.asciiLetter | $[_$\u{a1}-\u{10ffff}] }

  word { identifierChar (identifierChar | std.digit)* }

  identifier { word }

  @precedence { identifier, whitespace }

  @precedence { whitespace }

  @precedence { word, whitespace }

  Number {
    (std.digit ("_" | std.digit)* ("." ("_" | std.digit)*)? | "." std.digit ("_" | std.digit)*)
      (("e" | "E") ("+" | "-")? ("_" | std.digit)+)? |
    std.digit ("_" | std.digit)* "n" |
    "0x" (std.digit | $[a-fA-F] | "_")+ |
    "0b" $[01_]+ |
    "0o" $[0-7_]+
  }

  String {
    '"' (![\\\n"] | "\\" _)* '"'? |
    "'" (![\\\n'] | "\\" _)* "'"?
  }

  ArithOp<expr> { expr }
  LogicOp<expr> { expr }
  CompareOp<expr> { expr }
  UpdateOp<expr> { expr }

  RegExp { "/" (![/\\\n[] | "\\" ![\n] | "[" (![\n\\\]] | "\\" ![\n])* "]")+ ("/" $[gimsuy]*)? }

  LessThan[@name=CompareOp] { "<" }

  "="[@name=Equals]
  "..."[@name=Spread]
  "=>"[@name=Arrow]

  "(" ")" "[" "]" "{" "}"

  "?." "." "," ";" ":"
}

@external tokens insertSemicolon from "./tokens" { insertSemi }

@detectDelim
